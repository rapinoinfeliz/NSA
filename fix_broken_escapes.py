
import re
import os

file_path = 'src/modules/ui.mjs'

if not os.path.exists(file_path):
    print(f"File {file_path} NOT found.")
    exit(1)

with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()

def unescaper(match):
    # match.group(0) is the entire ' + (...) + ' block?
    # No, regex is tricky to match mostly balanced parens.
    # But my script generated simple `(expr)` wrappers.
    # However, expr can contain parentheses! `func(a, b)`
    # My regex needs to be smart or iterative.
    pass

# Simpler approach:
# The file consists of lines of code.
# The broken parts look like: ... + (func(\'arg\', \'arg\')) + ...
# We want to replace `\'` with `'` IF we are inside the parens generated by the previous script.
# But "inside parens" is hard.

# Alternative: 
# The broken syntax is `(\'`. Or `\')`. Or `\',`.
# `\` character followed by `'` is NOT valid in JS code unless in string.
# In my generated code, `(` starts expression context.
# So `(\'` is almost certainly wrong (start of string arg).
# `\')` is end of string arg.
# `\',` is comma between args.
# ` \+ ` is operator.

# So, effectively, ALL `\'` sequences that are NOT inside the string parts of the concatenation are bugs.
# The string parts are bounded by `' ... '`.
# The expression parts are between `' ... ' + (` and `) + ' ... '`.

# I will use a state machine parser in Python.
# Iterate chars.
# Toggle "in_string" when hitting `'` (ignoring `\'`).
# If NOT in_string, and we see `\'`, REVERT IT to `'`.

def fix_content(text):
    out = []
    i = 0
    length = len(text)
    in_string = False 
    # We start presumably NOT in string, or assuming start of file is code?
    # But the file is mixed.
    # Wait. `ui.js` content `html += '...'` starts string.
    # So we need to track quotes.
    # But "string" means the JS string literals `'...'`.
    
    while i < length:
        char = text[i]
        
        if char == "'" and (i == 0 or text[i-1] != '\\'):
            in_string = not in_string
            out.append(char)
            i += 1
            continue
        
        if char == '\\' and i + 1 < length and text[i+1] == "'":
            # Found `\'`.
            if in_string:
                # Inside string, `\'` is valid and necessary. Keep it.
                out.append('\\')
                out.append("'")
                i += 2
            else:
                # Outside string (in code expression), `\'` is INVALID.
                # It means we double-escaped it.
                # Replace `\'` with `'`.
                out.append("'") # omit backslash
                i += 2
        else:
            out.append(char)
            i += 1
            
    return "".join(out)

new_content = fix_content(content)

with open(file_path, 'w', encoding='utf-8') as f:
    f.write(new_content)

print("Escapes fixed.")
